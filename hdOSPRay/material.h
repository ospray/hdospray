// Copyright 2019 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

#pragma once

#include <pxr/base/gf/vec2f.h>
#include <pxr/base/gf/vec3f.h>
#include <pxr/base/gf/vec4f.h>
#include <pxr/pxr.h>
#include "pxr/imaging/hd/material.h"
#include "pxr/imaging/hd/sceneDelegate.h"

#include <ospray/ospray_cpp.h>
#include <ospray/ospray_cpp/ext/rkcommon.h>

#include "texture.h"

namespace opp = ospray::cpp;

PXR_NAMESPACE_USING_DIRECTIVE

typedef std::shared_ptr<class HdStTextureResource> HdStTextureResourceSharedPtr;

/// OSPRay hdMaterial
///  supports uvtextures and ptex when pxr_oiio_plugin
///  and pxr_ptex_plugin are enabled.
///  The OSPRay representation can be accessed via
///  GetOSPRayMaterial().
class HdOSPRayMaterial final : public HdMaterial {
public:
    HdOSPRayMaterial(SdfPath const& id);

    // TODO: free texture memory
    virtual ~HdOSPRayMaterial() = default;

    /// Synchronizes state from the delegate to this object.
    virtual void Sync(HdSceneDelegate* sceneDelegate,
                      HdRenderParam* renderParam,
                      HdDirtyBits* dirtyBits) override;

    /// Returns the minimal set of dirty bits to place in the
    /// change tracker for use in the first sync of this prim.
    /// Typically this would be all dirty bits.
    virtual HdDirtyBits GetInitialDirtyBitsMask() const override
    {
        return AllDirty;
    }

    /// Causes the shader to be reloaded.
    virtual void Reload()
    {
    }

    void SetDisplayColor(GfVec4f color);

    /// Create a default material based on the renderer type specified in config
    static opp::Material CreateDefaultMaterial(GfVec4f color);

    /// Create a default material based on the renderer type specified in config
    // static OSPMaterial CreateDiffuseMaterial(GfVec4f color);

    /// Create a default material based on the renderer type specified in config
    void UpdatePrincipledMaterial(const std::string& renderType);
    void UpdateCarPaintMaterial();
    void UpdateLuminousMaterial();
    void UpdateThinGlassMaterial();
    void UpdateGlassMaterial();

    /// Create a default material based on the renderer type specified in config
    void UpdateSimpleMaterial(const std::string& renderType);

    /// Create a default material based on the renderer type specified in config
    void UpdateScivisMaterial(const std::string& renderType);

    /// Summary flag. Returns true if the material is bound to one or more
    /// textures and any of those textures is a ptex texture.
    /// If no textures are bound or all textures are uv textures, then
    /// the method returns false.
    inline bool HasPtex() const
    {
        return hasPtex;
    }

    // Return the OSPMaterial object generated by Sync
    inline const opp::Material GetOSPRayMaterial() const
    {
        return _ospMaterial;
    }

private:
    inline float RoughnesToPhongExponent(float roughness)
    {
        if (roughness > 0.0f) {
            return std::min(2.0f / std::pow(roughness, 4.f) - 2.0f, 1000.0f);
        } else {
            return 1000.0f;
        }
    }

    inline float EvalAvgFresnel(float ior)
    {
        if (ior >= 400.0f) {
            return 1.0f;
        } else if (1.0f == ior) {
            return 0.0f;
        } else if (1.0 < ior) {
            return (ior - 1.0f) / (4.08567f + 1.00071f * ior);
        } else {
            return 0.997118f + 0.1014 * ior - 0.965241 * ior * ior
                   - 0.130607 * ior * ior * ior;
        }
    }

protected:
    // update osp representations for material
    void _UpdateOSPRayMaterial();
    // fill in material parameters based on usdPreviewSurface node
    void _ProcessUsdPreviewSurfaceNode(HdMaterialNode node);
    void _ProcessOspPrincipledNode(HdMaterialNode node);
    void _ProcessOspCarPaintNode(HdMaterialNode node);
    void _ProcessOspLuminousNode(HdMaterialNode node);
    void _ProcessOspThinGlassNode(HdMaterialNode node);
    void _ProcessOspGlassNode(HdMaterialNode node);
    // parse texture node params and set them to appropriate map_ texture var
    void _ProcessTextureNode(HdMaterialNode node, const TfToken& inputName,
                             const TfToken& outputName);
    // parse texture transformation node params and set rotation, translation,
    // and scale
    void _ProcessTransform2dNode(HdMaterialNode node, TfToken textureName);

    enum MaterialTypes { preview = 0, principled, carPaint, luminous, thinGlass, glass };
    MaterialTypes _type { MaterialTypes::preview };

    GfVec3f diffuseColor { 0.18f, 0.18f, 0.18f }; // also baseColor
    GfVec4f fallback { 0.f, 0.f, 0.f, 1.f };
    GfVec3f edgeColor { 1.0f, 1.0f, 1.0f };
    GfVec3f specularColor { 0.0f, 0.0f, 0.0f };
    float metallic { 0.f };
    float diffuse { 1.f };
    float specular { 1.f };
    //thinglass
    float eta {1.5f};
    GfVec3f attenuationColor {1.f, 1.f, 1.f};
    float attenuationDistance {1.f};

    float intensity { 1.f }; // luminous intensity
    float roughness { 0.5f };
    float normalScale { 1.f }; // normal map scale
    float transmission { 0.f };
    GfVec3f transmissionColor { 1.0f, 1.0f, 1.0f };
    float transmissionDepth { 1.f };
    float anisotropy { 0.f };
    float rotation { 0.f };
    float baseNormal { 1.f };
    GfVec3f flakeColor { 1.f, 1.f, 1.f };
    float flakeDensity { 0.f };
    float flakeScale { 100.0f };
    float flakeSpread { 0.3f };
    float flakeJitter { 0.75f };
    float flakeRoughness { 0.3f };
    bool thin { false };
    float thickness { 1.f };
    float backlight { 0.f };
    float coat { 0.f };
    float coatIor { 1.5f };
    GfVec3f coatColor { 1.f, 1.f, 1.f };
    float coatThickness { 1.f };
    float coatRoughness { 0.01f };
    float coatNormal { 1.f };
    GfVec3f flipflopColor { 1.f, 1.f, 1.f };
    float flipflopFalloff { 1.f };
    float ior { 1.0f };
    float opacity { 1.f }; // 1.f - transmission for preview
    float sheen { 0.f };
    GfVec3f sheenColor { 1.f, 1.f, 1.f };
    float sheenTint { 0.f };
    float sheenRoughness { 0.2f };
    GfVec3f emissiveColor { 0.f, 0.f, 0.f };
    TfToken type;
    bool hasPtex { false };

    bool _transformTexCoords { false };
    float _rotation { 0.f };
    GfVec2f _scale;
    GfVec2f _translation;
    bool _typeDirty { true };

    std::map<TfToken, HdOSPRayTexture> _textures;
    opp::Material _ospMaterial;
};